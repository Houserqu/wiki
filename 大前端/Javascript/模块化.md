## 模块引入顺序

首先加载核心模块,不管有没有同名/同目录的情况下,核心模块优先加载. 

其次按照相对路径/绝对路径加载文件模块(加载顺序,首先试图按照路径查找 .js 扩展名的文件,如果没有,试图按照路径查找 .json 扩展名的文件,如果还是没有,就按照路径查找 .node 扩展名的c++模块了) 

最后搜索 node_modules 目录下通过npm下载的第三方模块.  

注意:首次加载这类模块最慢,因为执行文件所在目录的node_mondel 文件夹下找不到时,会去父级node_mondel 文件夹里查找,如果还是找不到会去父级的父级node_mondel 文件夹里查找.......但是,只要首次加载成功后,node就会缓存起来,它缓存的是编译后的二进制模块,所以以后的加载速度和效率都的有保证的. 

## 简单模块化

1. 通过script标签实现模块化，但是依然会造成变量污染，而且还需要人为控制顺序

2. 通过立即执行函数进行函数作用域的隔离

## nodejs的规范CommonJs

一个文件就是一个模块，文件名就是模块的名字，使用模块的方法也和commonjs中一致，只需require就好了

```
module.export = add
var add = require('math');
```
缺点：
- 同步加载
- 不能非阻塞的并行加载多个模块

## AMD：Asynchronous Module Definition异步模块定义

示例

```
define("module", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
require(["module", "../file"], function(module, file) { /* ... */ });
```

优点：
- 适合在浏览器环境中异步加载模块
- 可以并行加载多个模块

缺点：
- 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅
- 不符合通用的模块化思维方式，是一种妥协的实现

## CMD规范

与CommonJS和Node.js的 Modules 规范保持了很大的兼容性。在CMD规范中，一个模块就是一个文件。

```
define(function(require, exports, module) {
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})
```

### AMD和CMD的区别

1、对于依赖的模块，AMD是提前执行，CMD是延迟执行。
2、AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require。

## ES6模块化

ES6 模块的设计思想，是尽量的静态化，使得**编译时就能确定模块的依赖关系**，以及输入和输出的变量，能够提供更好的**变量类型检查**。CommonJS和AMD模块，都只能在运行时确定这些东西。

[参考链接](http://xieyufei.com/2017/02/19/JS-Standard.html)